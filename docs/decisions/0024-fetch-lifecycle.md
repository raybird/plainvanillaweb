# ADR 0024: 非同步請求生命週期管理 (Fetch Lifecycle Management)

## 上下文
在單頁應用 (SPA) 中，非同步請求（如搜尋）常會遇到競爭條件 (Race Condition)。如果使用者快速觸發多次請求，且較晚發出的請求先返回，或者較早發出的請求蓋過最新結果，會導致 UI 數據不一致。此外，組件銷毀後若請求仍在進行，會浪費資源甚至引發錯誤。

## 決策
引入 **`APIService`** 與 **`AbortController`** 機制：
1.  **請求標識與取消**: 每個非同步請求類別都分配一個唯一的 Key。發起新請求時，若存在相同 Key 的舊請求且尚未完成，則調用 `abort()`。
2.  **服務封裝**: 將此邏輯封裝在 `lib/api-service.js` 中，提供 `fetchWithCancel` 接口，使組件無需手動管理 Controller。
3.  **無感錯誤處理**: 在 Service 層攔截 `AbortError`，回傳 `null` 並由組件進行過濾，確保被取消的請求不會引發全局錯誤。

## 後果
- **優點**: 徹底解決 API 競爭條件，提升應用穩定性與數據精確度。
- **優點**: 節省客戶端頻寬與處理器資源。
- **缺點**: 需要開發者養成使用 `APIService` 的習慣，而非直接呼叫 `fetch`。
